package eu.davidgamez.mas.midi;

//Java imports
import javax.sound.midi.*;

import java.util.Collection;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.ArrayList;
import java.util.Vector;

//MAS imports
import eu.davidgamez.mas.event.TransportListener;
import eu.davidgamez.mas.midi.*;
import eu.davidgamez.mas.*;
import eu.davidgamez.mas.exception.*;
import eu.davidgamez.mas.event.*;
import eu.davidgamez.mas.gui.MsgHandler;

/**
 * ---------------------------- MIDISequencer ---------------------------------
 * The class that handles the playing of the notes generated by the agents.
 * //#FIXME# THIS CLASS CANNOT CURRENTLY HANDLE SEVERAL MIDI INPUT OR OUTPUT
 * DEVICES WITH THE SAME NAME
 * 
 * FIXME: CONNECT TO EXIT EVENT AND CLOSE DEVICES
 * -----------------------------------------------------------------------------
 */
public class MASSequencer implements Constants, TransportListener, BufferListener {

	/** Class that plays MIDI messages as a separate thread. */
	private MIDIPlayer midiPlayer = new MIDIPlayer();
	
	/** Class that plays OSC messages as a separate thread. */
	private MIDIPlayer oscPlayer = new MIDIPlayer();

	
	/** Constructor */
	public MASSequencer() {
		//Initialize static arrays etc. in the buffer
		Buffer.init();

		//Register to listen for events
		EventRouter.addBufferListener(this);
		EventRouter.addTransportListener(this);
	}


	/*-----------------------------------------------------------------*/
	/*------                  PUBLIC METHODS                   --------*/
	/*-----------------------------------------------------------------*/	

	/** Method inherited from TransportListener interface */
	public void killNotesActionPerformed(){
		//Stop sequencer if it is playing
		if(midiPlayer.isPlaying())
			stop();
		
		//Send note off messages to all the current receivers
		ShortMessage noteOffMsg = new ShortMessage();
		try{
			//Get the tracks and the receivers
			ArrayList<Receiver> receiverArrayList = MIDIDeviceManager.getReceiverArrayList();
			Collection<Track> trackList = TrackHolder.getTracks();
			
			//Avoid sending note off messages twice to the same channel
			HashMap<Integer, Boolean> channelUpdateMap = new HashMap<Integer, Boolean>();
			
			//Work through the tracks
			for(Track tmpTrk : trackList ){
				if( !channelUpdateMap.containsKey( new Integer(tmpTrk.getChannel() ) ) ){
					
					//Work through the receivers
					for(Receiver receiver : receiverArrayList){
						
						//Send note off command for all the notes
						for(int notePitch=0; notePitch<127; ++notePitch){
							noteOffMsg.setMessage(ShortMessage.NOTE_OFF, tmpTrk.getChannel(), notePitch, 0);
							receiver.send(noteOffMsg,-1);
						}
					}
					channelUpdateMap.put(new Integer(tmpTrk.getChannel()), new Boolean(true));
				}
			}
		}
		catch(Exception ex){
			MsgHandler.error(ex);
		}
	}


	/** Method inherited from TransportListener interface.
	 * Play is initiated by the agent handler when enough buffers have been filled up.
	 */
	public void playActionPerformed(){
	}

	public void stopActionPerformed(){
	}

	/** The invocation of this method is controlled by the agent handler
	    when enough buffers have been filled up */
	public void play(){
		if(!midiPlayer.isPlaying()){
			midiPlayer = new MIDIPlayer();
			midiPlayer.start();
		}
	}


	public void stop() {
		System.out.println("Stopping sequencer.");
		
		if(!midiPlayer.isPlaying())
			return;
			
		//Stop the MIDIPLayer
		midiPlayer.stopThread();
		try {
			midiPlayer.join(5000);
		} 
		catch (InterruptedException e) {
			MsgHandler.critical("Exception thrown waiting for MIDI Player to stop");
			e.printStackTrace();
		}

		//Check for errors in the MIDIPlayer
		if(midiPlayer.isError())
			MsgHandler.critical(midiPlayer.getErrorMessage());

		//Reset the buffer
		Buffer.reset();
	}


	/** Method inherited from BufferListener */
	public void endLoadBufferAdvanceOccurred(long bufferCount) {
//		if(Globals.isPlaying())
//			return;
//
//		//Start sequencer when load buffer has advanced beyond starting point
//		if (Buffer.getLoadBufferCount() >= Buffer.getHeadStart_buffers()) {
//			play();
//		}
	}

	
	/** Method inherited from BufferListener */
	public void startLoadBufferAdvanceOccurred(long bufferCount) {
	}

	
	/** Unused method from BufferListener interface */
	public void playBufferAdvanceOccurred(long bufferCount) {	
	}


	/** Unused method from BufferListener interface */
	public void trackAdvanceOccurred(long tickCount) {
	}


	/** Resets all buffers etc. */
	public void reset() {
		Buffer.reset();
	}


}
